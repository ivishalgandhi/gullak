// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createAsset = `-- name: CreateAsset :one

INSERT INTO assets (
    created_at, institution_name, institution_type, 
    asset_name, current_value, currency, 
    last_updated, description, confirm
)
VALUES (
    CURRENT_TIMESTAMP, ?, ?, 
    ?, ?, ?, 
    CURRENT_TIMESTAMP, ?, ?
)
RETURNING id, created_at, institution_name, institution_type, asset_name, current_value, currency, last_updated, description, confirm
`

type CreateAssetParams struct {
	InstitutionName string  `json:"institution_name"`
	InstitutionType string  `json:"institution_type"`
	AssetName       string  `json:"asset_name"`
	CurrentValue    float64 `json:"current_value"`
	Currency        string  `json:"currency"`
	Description     string  `json:"description"`
	Confirm         bool    `json:"confirm"`
}

// Asset Management Queries
// Creates a new asset
func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.queryRow(ctx, q.createAssetStmt, createAsset,
		arg.InstitutionName,
		arg.InstitutionType,
		arg.AssetName,
		arg.CurrentValue,
		arg.Currency,
		arg.Description,
		arg.Confirm,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.InstitutionName,
		&i.InstitutionType,
		&i.AssetName,
		&i.CurrentValue,
		&i.Currency,
		&i.LastUpdated,
		&i.Description,
		&i.Confirm,
	)
	return i, err
}

const createAssetHistory = `-- name: CreateAssetHistory :one
INSERT INTO asset_history (
    asset_id, value_date, value, currency
)
VALUES (?, CURRENT_TIMESTAMP, ?, ?)
RETURNING id, asset_id, value_date, value, currency
`

type CreateAssetHistoryParams struct {
	AssetID  int64   `json:"asset_id"`
	Value    float64 `json:"value"`
	Currency string  `json:"currency"`
}

// Creates a history record for an asset value change
func (q *Queries) CreateAssetHistory(ctx context.Context, arg CreateAssetHistoryParams) (AssetHistory, error) {
	row := q.queryRow(ctx, q.createAssetHistoryStmt, createAssetHistory, arg.AssetID, arg.Value, arg.Currency)
	var i AssetHistory
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.ValueDate,
		&i.Value,
		&i.Currency,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :many
INSERT INTO transactions (created_at, transaction_date, amount, currency, category, description, confirm)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, created_at, transaction_date, currency, amount, category, description, confirm
`

type CreateTransactionParams struct {
	CreatedAt       time.Time `json:"created_at"`
	TransactionDate time.Time `json:"transaction_date"`
	Amount          float64   `json:"amount"`
	Currency        string    `json:"currency"`
	Category        string    `json:"category"`
	Description     string    `json:"description"`
	Confirm         bool      `json:"confirm"`
}

// Inserts a new transaction into the database.
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.createTransactionStmt, createTransaction,
		arg.CreatedAt,
		arg.TransactionDate,
		arg.Amount,
		arg.Currency,
		arg.Category,
		arg.Description,
		arg.Confirm,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TransactionDate,
			&i.Currency,
			&i.Amount,
			&i.Category,
			&i.Description,
			&i.Confirm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailySpending = `-- name: DailySpending :many


SELECT
    transaction_date,
    SUM(amount) AS total_spent
FROM transactions
WHERE transaction_date BETWEEN ?1 AND ?2 AND confirm = 1
GROUP BY transaction_date
ORDER BY transaction_date ASC
`

type DailySpendingParams struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
}

type DailySpendingRow struct {
	TransactionDate time.Time       `json:"transaction_date"`
	TotalSpent      sql.NullFloat64 `json:"total_spent"`
}

// Can be adjusted to show more or fewer categories
// Retrieves the sum total of all transactions for each day within a specified date range.
func (q *Queries) DailySpending(ctx context.Context, arg DailySpendingParams) ([]DailySpendingRow, error) {
	rows, err := q.query(ctx, q.dailySpendingStmt, dailySpending, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DailySpendingRow{}
	for rows.Next() {
		var i DailySpendingRow
		if err := rows.Scan(&i.TransactionDate, &i.TotalSpent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAsset = `-- name: DeleteAsset :exec
DELETE FROM assets WHERE id = ?
`

// Deletes an asset
func (q *Queries) DeleteAsset(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteAssetStmt, deleteAsset, id)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = ?
`

// Deletes a transaction by ID.
func (q *Queries) DeleteTransaction(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteTransactionStmt, deleteTransaction, id)
	return err
}

const getAsset = `-- name: GetAsset :one
SELECT id, created_at, institution_name, institution_type, asset_name, current_value, currency, last_updated, description, confirm FROM assets WHERE id = ?
`

// Gets a specific asset by ID
func (q *Queries) GetAsset(ctx context.Context, id int64) (Asset, error) {
	row := q.queryRow(ctx, q.getAssetStmt, getAsset, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.InstitutionName,
		&i.InstitutionType,
		&i.AssetName,
		&i.CurrentValue,
		&i.Currency,
		&i.LastUpdated,
		&i.Description,
		&i.Confirm,
	)
	return i, err
}

const getAssetByInstitution = `-- name: GetAssetByInstitution :one
SELECT id, created_at, institution_name, institution_type, asset_name, current_value, currency, last_updated, description, confirm FROM assets 
WHERE institution_name = ? 
AND institution_type = ? 
AND asset_name = ?
`

type GetAssetByInstitutionParams struct {
	InstitutionName string `json:"institution_name"`
	InstitutionType string `json:"institution_type"`
	AssetName       string `json:"asset_name"`
}

// Gets an asset by institution name, type and asset name
func (q *Queries) GetAssetByInstitution(ctx context.Context, arg GetAssetByInstitutionParams) (Asset, error) {
	row := q.queryRow(ctx, q.getAssetByInstitutionStmt, getAssetByInstitution, arg.InstitutionName, arg.InstitutionType, arg.AssetName)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.InstitutionName,
		&i.InstitutionType,
		&i.AssetName,
		&i.CurrentValue,
		&i.Currency,
		&i.LastUpdated,
		&i.Description,
		&i.Confirm,
	)
	return i, err
}

const getAssetHistory = `-- name: GetAssetHistory :many
SELECT id, asset_id, value_date, value, currency FROM asset_history 
WHERE asset_id = ? 
ORDER BY value_date DESC
`

// Gets the value history for an asset
func (q *Queries) GetAssetHistory(ctx context.Context, assetID int64) ([]AssetHistory, error) {
	rows, err := q.query(ctx, q.getAssetHistoryStmt, getAssetHistory, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssetHistory{}
	for rows.Next() {
		var i AssetHistory
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.ValueDate,
			&i.Value,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, created_at, transaction_date, currency, amount, category, description, confirm FROM transactions WHERE id = ?
`

// Retrieves a single transaction by ID.
func (q *Queries) GetTransaction(ctx context.Context, id int64) (Transaction, error) {
	row := q.queryRow(ctx, q.getTransactionStmt, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.TransactionDate,
		&i.Currency,
		&i.Amount,
		&i.Category,
		&i.Description,
		&i.Confirm,
	)
	return i, err
}

const listAssets = `-- name: ListAssets :many
SELECT id, created_at, institution_name, institution_type, asset_name, current_value, currency, last_updated, description, confirm FROM assets 
WHERE (?1 IS NULL OR confirm = ?1)
ORDER BY created_at DESC
`

// Lists all assets
func (q *Queries) ListAssets(ctx context.Context, confirm interface{}) ([]Asset, error) {
	rows, err := q.query(ctx, q.listAssetsStmt, listAssets, confirm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Asset{}
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.InstitutionName,
			&i.InstitutionType,
			&i.AssetName,
			&i.CurrentValue,
			&i.Currency,
			&i.LastUpdated,
			&i.Description,
			&i.Confirm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, created_at, transaction_date, currency, amount, category, description, confirm
FROM transactions
WHERE (?1 IS NULL OR confirm = ?1)
  AND (?2 IS NULL OR transaction_date >= ?2)
  AND (?3 IS NULL OR transaction_date <= ?3)
ORDER BY transaction_date DESC, created_at DESC
`

type ListTransactionsParams struct {
	Confirm   interface{} `json:"confirm"`
	StartDate interface{} `json:"start_date"`
	EndDate   interface{} `json:"end_date"`
}

// Retrieves transactions optionally filtered by confirmation status and date range.
func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.listTransactionsStmt, listTransactions, arg.Confirm, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TransactionDate,
			&i.Currency,
			&i.Amount,
			&i.Category,
			&i.Description,
			&i.Confirm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlySpendingSummary = `-- name: MonthlySpendingSummary :many
SELECT
    strftime('%Y', transaction_date) AS year,
    strftime('%m', transaction_date) AS month,
    category,
    SUM(amount) AS total_spent
FROM transactions
GROUP BY year, month, category
ORDER BY year DESC, month DESC, total_spent DESC
`

type MonthlySpendingSummaryRow struct {
	Year       interface{}     `json:"year"`
	Month      interface{}     `json:"month"`
	Category   string          `json:"category"`
	TotalSpent sql.NullFloat64 `json:"total_spent"`
}

// TODO: This is not live yet.
// Returns the total spending grouped by month and category.
func (q *Queries) MonthlySpendingSummary(ctx context.Context) ([]MonthlySpendingSummaryRow, error) {
	rows, err := q.query(ctx, q.monthlySpendingSummaryStmt, monthlySpendingSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonthlySpendingSummaryRow{}
	for rows.Next() {
		var i MonthlySpendingSummaryRow
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.Category,
			&i.TotalSpent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topExpenseCategories = `-- name: TopExpenseCategories :many
SELECT
    category,
    SUM(amount) AS total_spent
FROM transactions
WHERE transaction_date BETWEEN ?1 AND ?2 AND confirm = 1
GROUP BY category
ORDER BY total_spent DESC
LIMIT 5
`

type TopExpenseCategoriesParams struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
}

type TopExpenseCategoriesRow struct {
	Category   string          `json:"category"`
	TotalSpent sql.NullFloat64 `json:"total_spent"`
}

// Retrieves the top expense categories over a specified period.
// Uses parameters: confirm, startDate, endDate to filter by transaction date range.
func (q *Queries) TopExpenseCategories(ctx context.Context, arg TopExpenseCategoriesParams) ([]TopExpenseCategoriesRow, error) {
	rows, err := q.query(ctx, q.topExpenseCategoriesStmt, topExpenseCategories, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TopExpenseCategoriesRow{}
	for rows.Next() {
		var i TopExpenseCategoriesRow
		if err := rows.Scan(&i.Category, &i.TotalSpent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssetValue = `-- name: UpdateAssetValue :one
UPDATE assets 
SET current_value = ?, 
    currency = ?,
    last_updated = CURRENT_TIMESTAMP,
    confirm = ?
WHERE id = ? 
RETURNING id, created_at, institution_name, institution_type, asset_name, current_value, currency, last_updated, description, confirm
`

type UpdateAssetValueParams struct {
	CurrentValue float64 `json:"current_value"`
	Currency     string  `json:"currency"`
	Confirm      bool    `json:"confirm"`
	ID           int64   `json:"id"`
}

// Updates an asset's value
func (q *Queries) UpdateAssetValue(ctx context.Context, arg UpdateAssetValueParams) (Asset, error) {
	row := q.queryRow(ctx, q.updateAssetValueStmt, updateAssetValue,
		arg.CurrentValue,
		arg.Currency,
		arg.Confirm,
		arg.ID,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.InstitutionName,
		&i.InstitutionType,
		&i.AssetName,
		&i.CurrentValue,
		&i.Currency,
		&i.LastUpdated,
		&i.Description,
		&i.Confirm,
	)
	return i, err
}

const updateAssetValueAndHistory = `-- name: UpdateAssetValueAndHistory :exec
UPDATE assets 
SET current_value = ?, 
    currency = ?,
    last_updated = CURRENT_TIMESTAMP,
    confirm = ?
WHERE id = ?
`

type UpdateAssetValueAndHistoryParams struct {
	CurrentValue float64 `json:"current_value"`
	Currency     string  `json:"currency"`
	Confirm      bool    `json:"confirm"`
	ID           int64   `json:"id"`
}

// Updates an asset's value and creates a history record
func (q *Queries) UpdateAssetValueAndHistory(ctx context.Context, arg UpdateAssetValueAndHistoryParams) error {
	_, err := q.exec(ctx, q.updateAssetValueAndHistoryStmt, updateAssetValueAndHistory,
		arg.CurrentValue,
		arg.Currency,
		arg.Confirm,
		arg.ID,
	)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :exec
UPDATE transactions
SET amount = ?, currency = ?, category = ?, description = ?, confirm = ?, transaction_date = ?
WHERE id = ?
`

type UpdateTransactionParams struct {
	Amount          float64   `json:"amount"`
	Currency        string    `json:"currency"`
	Category        string    `json:"category"`
	Description     string    `json:"description"`
	Confirm         bool      `json:"confirm"`
	TransactionDate time.Time `json:"transaction_date"`
	ID              int64     `json:"id"`
}

// Updates a transaction by ID.
func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.exec(ctx, q.updateTransactionStmt, updateTransaction,
		arg.Amount,
		arg.Currency,
		arg.Category,
		arg.Description,
		arg.Confirm,
		arg.TransactionDate,
		arg.ID,
	)
	return err
}
